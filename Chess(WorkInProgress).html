<!DOCTYPE html>
<html>
    <head>
        <style>
            canvas {
                border: 3px solid #000;
                background: url('data:image/gif;base64,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');
                width:  100%;
                aspect-ratio: 1 / 1;
                overflow: hidden;
            }
        </style>
    </head>

    <body>
        <canvas id="canvas"></canvas>
        <script>
            const d = document.getElementById("canvas");
            const c = d.getContext("2d");

            class Piece {
                constructor(color, size){
                    this.color = color;
                    this.size = size;
                }
                isOnBoard(x, y){
                    console.log(w.field[y][x].Figure + "," + x + "," + y);
                    return w.field[y][x].Figure !== null;
                }

                isSameColor(x, y){
                    console.log("x and Why: " + x + "," + y);
                    return w.field[y][x].Figure.piece.color === this.color;
                }
            }

            class Pawn{
                constructor(color, size){
                    this.piece = new Piece(color,size);
                }

                possibleMoves(x, y){
                    let result = [];
                    if (this.piece.color === w.black && y < 7){
                        if (x - 1 >= 0 && this.piece.isOnBoard(x - 1, y + 1) && !this.piece.isSameColor(x - 1, y + 1)){
                            result.push({x: x - 1, y: y + 1 });
                        }
                        if (x + 1 < 8 && this.piece.isOnBoard(x + 1, y + 1) && !this.piece.isSameColor(x + 1, y + 1)){
                            result.push({x: x + 1, y: y + 1});
                        }
                        if (!this.piece.isOnBoard(x, y + 1)){
                            result.push({x: x, y: y + 1});
                            if (y === 1 && !this.piece.isOnBoard(x, y + 2)){
                                result.push({x: x, y: y + 2});
                            }
                        }
                    }

                    if (this.piece.color === w.white && y >= 0){
                        if (x - 1 >= 0 && this.piece.isOnBoard(x - 1, y - 1) && !this.piece.isSameColor(x - 1, y - 1)){
                            result.push({x: x - 1, y: y - 1});
                        }
                        if (x + 1 < 8 && this.piece.isOnBoard(x + 1, y - 1) && !this.piece.isSameColor(x + 1, y - 1)){
                            result.push({x: x + 1, y: y - 1});
                        }
                        if (!this.piece.isOnBoard(x, y - 1)){
                            result.push({x: x, y: y - 1});
                            if (y === 6 && !this.piece.isOnBoard(x, y - 2)){
                                result.push({x: x, y: y - 2});
                            }
                        }
                    }
                    return result;
                }

                display(x, y, scale){
                    c.fillStyle = this.piece.color;
                    c.beginPath();
                    c.arc((x + this.piece.size / 8 * 5) * scale,
                          (y + this.piece.size / 8 * 5) * scale,
                          (this.piece.size / 2.5) * scale,
                          0,
                          2 * Math.PI);
                    c.fill();
                }
            }

            class Rook{
                constructor(color, size){
                    this.piece = new Piece(color, size); 
                }

                possibleMoves(x, y){
                    let result = [];

                    function possibleMovesInLine(xIndex, yIndex, testFunction, piece){
                        for (let i = 1; testFunction(i); i++){
                            let position = {
                                x: xIndex(i),
                                y: yIndex(i)
                            };
                            if (piece.isOnBoard(xIndex(i), yIndex(i))){
                                if(!piece.isSameColor(xIndex(i), yIndex(i))){
                                    result.push(position);
                                }
                                break;
                            }
                            result.push(position);
                        }
                    }

                    possibleMovesInLine(
                        i => x + i,
                        i => y,
                        i => x + i < 8,
                        this.piece
                    );

                    possibleMovesInLine(
                        i => x - i,
                        i => y,
                        i => x - i >= 0,
                        this.piece
                    );

                    possibleMovesInLine(
                        i => x,
                        i => y + i,
                        i => y + i < 8,
                        this.piece
                    );

                    possibleMovesInLine(
                        i => x,
                        i => y - i,
                        i => y - i >= 0,
                        this.piece
                    );

                    return result;
                }

                display(x, y, scale){
                    c.fillStyle = this.piece.color;
                    c.fillRect((x + this.piece.size / 8) * scale,
                               (y + this.piece.size / 8) * scale,
                               this.piece.size * scale,
                               this.piece.size * scale);
                }
            }
            1,2
            class Knight{
                constructor(color, size){
                    this.piece = new Piece(color, size);
                }

                possibleMoves(x, y){
                    let result = [];
                    function pieceCheck(x, y, piece) {
                        if(!piece.isOnBoard(x, y) 
                        || !piece.isSameColor(x, y)){
                            result.push({x: x, y: y});
                        }
                    };
                    if (x + 1 < 8){
                        if (y + 2 < 8){
                            pieceCheck(x + 1, y + 2, this.piece);
                        }
                        if (y - 2 >= 0){
                            pieceCheck(x + 1, y - 2, this.piece);
                        }
                    }
                    if (x - 1 >= 0){
                        if (y + 2 < 8){
                            pieceCheck(x - 1, y + 2, this.piece);
                        }
                        if (y - 2 >= 0){
                            pieceCheck(x - 1, y - 2, this.piece);
                        }
                    }
                    if (x + 2 < 8){
                        if(y + 1 < 8){
                            pieceCheck(x + 2, y + 1, this.piece);
                        }
                        if(y - 1 >= 0){
                            pieceCheck(x + 2, y - 1, this.piece);
                        }
                    }
                    if (x - 2 >= 0){
                        if(y + 1 < 8){
                            pieceCheck(x - 2, y + 1, this.piece);
                        }
                        if(y - 1 >= 0){
                            pieceCheck(x - 2, y - 1, this.piece);
                        }
                    }
                    return result;
                }

                display(x, y, scale){
                    c.fillStyle = this.piece.color;
                    c.fillRect((x + this.piece.size / 2) * scale,
                               (y + this.piece.size / 8) * scale,
                               this.piece.size / 4 * scale,
                               this.piece.size * scale);
                    c.fillRect((x + this.piece.size / 8) * scale,
                               (y + this.piece.size / 8 * 3) * scale,
                               this.piece.size * scale,
                               this.piece.size / 8 * scale);
                    c.fillRect((x + this.piece.size / 8) * scale,
                               (y + this.piece.size / 4 * 3) * scale,
                               this.piece.size * scale,
                               this.piece.size / 8 * scale);
                }
            }

            class Bishop{
                constructor(color, size){
                    this.piece = new Piece(color,size);
                }

                possibleMoves(x, y){
                    let result = [];

                    function possibleMovesInLine(xIndex, yIndex, testFunction, piece){
                        for(let i = 0; testFunction(i); i++){
                            let position = {
                                x: xIndex(i),
                                y: yIndex(i)
                            }
                            if(piece.isOnBoard(xIndex(i), yIndex(i))){
                                if(!piece.isSameColor(xIndex(i), yIndex(i))){
                                    result.push(position);
                                }
                                break;
                            }
                            result.push(position);
                        }
                    }

                    possibleMovesInLine(
                        i => x + i,
                        i => y + i,
                        i => x + i < 8 && y + i < 8,
                        this.piece
                    );

                    possibleMovesInLine(
                        i => x - i,
                        i => y - i,
                        i => x - i >= 0 && y - i >= 0,
                        this.piece
                    );

                    possibleMovesInLine(
                        i => x + i,
                        i => y - i,
                        i => x + i < 8 && y - i >= 0,
                        this.piece
                    );

                    possibleMovesInLine(
                        i => x - i,
                        i => y + i,
                        i => x - i >= 0 && y + i < 8,
                        this.piece
                    );

                    return result;
                }

                display(x, y, scale){
                    c.fillStyle = this.piece.color;
                    function drawCircle(x, y, size){
                        c.beginPath();
                        c.arc(
                          x * scale,
                          y * scale,
                          (size / 4) * scale,
                          0,
                          2 * Math.PI);
                        c.fill();
                    }

                    drawCircle(x + 35, y + 35, this.piece.size);
                    drawCircle(x + 35, y + 65, this.piece.size);
                    drawCircle(x + 65, y + 65, this.piece.size);
                    drawCircle(x + 65, y + 35, this.piece.size);
                }
            }

            class Queen{
                constructor(color, size){
                    this.piece = new Piece(color, size);
                }

                possibleMoves(x, y){
                    let result = [];
                    function possibleMovesInLine(xIndex, yIndex, testFunction, piece){
                        for(let i = 0; testFunction(i); i++){
                            let position = {
                                x: xIndex(i),
                                y: yIndex(i)
                            }
                            if(piece.isOnBoard(xIndex(i), yIndex(i))){
                                if(!piece.isSameColor(xIndex(i), yIndex(i))){
                                    result.push(position);
                                }
                                break;
                            }
                            result.push(position);
                        }
                    }

                    possibleMovesInLine(
                        i => x + i,
                        i => y + i,
                        i => x + i < 8 && y + i < 8,
                        this.piece
                    );

                    possibleMovesInLine(
                        i => x - i,
                        i => y - i,
                        i => x - i >= 0 && y - i >= 0,
                        this.piece
                    );

                    possibleMovesInLine(
                        i => x + i,
                        i => y - i,
                        i => x + i < 8 && y - i >= 0,
                        this.piece
                    );

                    possibleMovesInLine(
                        i => x - i,
                        i => y + i,
                        i => x - i >= 0 && y + i < 8,
                        this.piece
                    );

                    possibleMovesInLine(
                        i => x + i,
                        i => y,
                        i => x + i < 8,
                        this.piece
                    );

                    possibleMovesInLine(
                        i => x - i,
                        i => y,
                        i => x - i >= 0,
                        this.piece
                    );

                    possibleMovesInLine(
                        i => x,
                        i => y + i,
                        i => y + i < 8,
                        this.piece
                    );

                    possibleMovesInLine(
                        i => x,
                        i => y - i,
                        i => y - i >= 0,
                        this.piece
                    );

                    return result;
                }

                display(x, y, scale){
                    c.fillStyle = this.piece.color;
                    c.fillRect((x + this.piece.size / 8) * scale,
                               (y + this.piece.size / 16 * 9) * scale,
                               this.piece.size * scale,
                               this.piece.size / 8 * scale);
                    c.fillRect((x + this.piece.size / 16 * 9) * scale,
                               (y + this.piece.size / 8) * scale,
                               this.piece.size / 8 * scale,
                               this.piece.size * scale);
                    c.beginPath();
                    c.arc((x + this.piece.size / 8 * 5) * scale,
                          (y + this.piece.size / 8 * 5) * scale,
                          (this.piece.size / 3) * scale,
                          0,
                          2 * Math.PI);
                    c.fill();

                }
            }

            class King{
                constructor(color, size){
                    this.piece = new Piece(color, size);
                }

                possibleMoves(x, y){
                    let result = [];
                    function pieceCheck(x, y, piece) {
                        if(!piece.isOnBoard(x, y) 
                        || !piece.isSameColor(x, y)){
                            result.push({x: x, y: y});
                        }
                    };

                    if(x + 1 < 8){
                        if(y + 1 < 8){
                            pieceCheck(x + 1, y + 1, this.piece);
                        }
                        if(y - 1 >= 0){
                            pieceCheck(x + 1, y - 1, this.piece);
                        }
                        pieceCheck(x + 1, y, this.piece);
                    }
                    if((x - 1 >= 0)){
                        if(y + 1 < 8){
                            pieceCheck(x - 1, y + 1, this.piece);
                        }
                        if(y - 1 >= 0){
                            pieceCheck(x - 1, y - 1, this.piece);
                        }
                        pieceCheck(x - 1, y, this.piece);
                    }
                    if(y + 1 < 8){
                        pieceCheck(x, y + 1, this.piece);
                    }
                    if(y - 1 >= 0){
                        pieceCheck(x, y - 1, this.piece);
                    }
                    return result;
                }

                display(x, y, scale){
                    c.fillStyle = this.piece.color;
                    c.fillRect((x + this.piece.size / 8 * 3) * scale,
                               (y + this.piece.size / 32 * 3) * scale,
                               this.piece.size / 2 * scale,
                               this.piece.size / 16 * 17 * scale);
                    c.fillRect((x + this.piece.size /  32 * 3) * scale,
                               (y + this.piece.size / 8 * 3) * scale,
                               this.piece.size / 16 * 17 * scale,
                               this.piece.size / 2 * scale);
                }
            }

            class Tile{

                constructor(xNum,yNum,Figure) {
                    this.x = xNum * 100;
                    this.y = yNum * 100;
                    this.Figure = Figure;
                    if (
                      (xNum % 2 === 0 && yNum % 2 === 0) ||
                      (xNum % 2 === 1 && yNum % 2 === 1)){
                        this.color = "white";
                    }else{
                        this.color = "black";
                    }
                }

                display(scale) {
                    c.fillStyle = this.color;
                    c.fillRect(
                        this.x * scale,
                        this.y * scale,
                        w.squareWidth * scale,
                        w.squareHeight * scale);
                    if (this.Figure != null){
                        console.log("Figure_Output");
                        this.Figure.display(this.x,
                                            this.y,
                                            scale);
                    }
                }
            }

            class World{

                constructor() {
                    this.field = [];
                    this.maxX = 800;
                    this.maxY = 800;
                    this.figureSize = 80;
                    this.squareWidth = this.maxX / 8;
                    this.squareHeight = this.maxY / 8;
                    this.scaleValue = d.getBoundingClientRect().width / this.maxX;
                    this.black = "#4d2900";
                    this.white = "#fcffa6";
                    this.fillField();
                }//          fills the field with squares and their figures

                backRow(color, y){
                        return  [new Tile(0, y, new Rook(color, this.figureSize)),
                                new Tile(1, y, new Knight(color, this.figureSize)),
                                new Tile(2, y, new Bishop(color, this.figureSize)),
                                new Tile(3, y, new Queen(color, this.figureSize)),
                                new Tile(4, y, new King(color, this.figureSize)),
                                new Tile(5, y, new Bishop(color, this.figureSize)),
                                new Tile(6, y, new Knight(color, this.figureSize)),
                                new Tile(7, y, new Rook(color, this.figureSize))];
                }

                pawnRow(color, y){
                    let row = []
                    for (let x = 0; x < 8; x++){
                        row.push(new Tile(x, y, new Pawn(color, this.figureSize)));
                    }
                    return row;
                }

                emptyRow(y){
                    let row = []
                    for (let x = 0; x < 8; x++){
                        row.push(new Tile(x, y, null));
                    }
                    return row;
                }

                fillField(){
                    for (let y = 0; y < 8; y++){
                            //  0 = empty, 1 = pawn 2 = rook 3 = horse 4 = priest 5 = queen 6 =  King  
                        switch(y){
                            case 0:
                                this.field[y] = this.backRow(this.black, y);
                                break;
                            case 1:
                                this.field[y] = this.pawnRow(this.black, y);
                                break;
                            case 6:
                                this.field[y] = this.pawnRow(this.white, y);
                                break;
                            case 7:
                                this.field[y] = this.backRow(this.white,y);
                                break;
                            default:
                                this.field[y] = this.emptyRow(y);
                        }
                    }
                }
                

                selectPiece(worldX, worldY){
                    let x = Math.trunc((worldX / this.scaleValue) / 100);
                    let y = Math.trunc((worldY / this.scaleValue) / 100);
                    console.log("Coordinates: " + x +","+ y)
                    if (x < 8 && x >= 0 && y < 8 && y >= 0){
                        if (this.field[y][x].Figure !== null){
                            console.log("Figure which moves" + this.field[y][x].Figure)
                            let moves = this.field[y][x].Figure.possibleMoves(x, y);
                            console.log("Amount of moves" + moves.length);
                            for (let i = 0; i <= moves.length-1; i++){
                                console.log("move inside moves" + moves[i]);
                                c.fillStyle = "Green";
                                c.beginPath();
                                c.arc((moves[i].x * 100 + 50) * this.scaleValue,
                                (moves[i].y * 100 + 50) * this.scaleValue,
                                (this.size / 2) * this.scaleValue,
                                0,
                                2 * Math.PI);
                                c.fill();
                            } 
                        }
                    }
                }

                movePiece(x, y, newX, newY){
                    if (this.field[y][x].Figure != null){
                        if (newX < 8 && newX >= 0 && newY < 8 && newY >= 0){
                            if(this.field[y][x].Figure.move(x, y, newX, newY)){
                                this.field[newX][newY].Figure = this.field[y][x].Figure;
                                this.field[y][x].Figure = null; 
                            }
                        }
                    }

                }

                displayWorld(){
                    for (let x = 0; x < 8; x++){
                        for (let y = 0; y < 8; y++){
                            console.log("X and Y :" + x + y);
                            this.field[y][x].display(this.scaleValue);
                        }
                    }
                }

            }

            const w = new World();

            function game() {setTimeout(() => {
                // clears the screen
                requestAnimationFrame(game);
            }, 1)}

            function main() {
                // sets canvas width and height
                d.width = d.clientWidth;
                d.height = d.clientHeight;
                w.displayWorld();

                document.addEventListener(
                    'pointermove',
                    e => {w.selectPiece(e.clientX - document.body.getBoundingClientRect().left, e.clientY - document.body.getBoundingClientRect().top);}
                );

                document.addEventListener(
                    'dblclick',
                    e => {w.movePiece(e.clientX - document.body.getBoundingClientRect().left, e.clientY - document.body.getBoundingClientRect().top);}
                );

                game();
            }

            main();
        </script>
    </body>
</html>